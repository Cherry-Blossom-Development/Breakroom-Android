Claude review of iPhone vs Android features

What Would Stay THE SAME
                  
  1. App Architecture & Structure

     - 5-tab bottom navigation (Breakroom, Chat, Employment, Company, Tool Shed)
     - Hamburger menu with shortcuts, profile, logout
     - Conditional root view (Login vs Main based on auth state)
     - Feature-based file organization

  2. Data Models

     - All model structures (User, ChatRoom, ChatMessage, Ticket, BlogPost, etc.)
     - JSON parsing with snake_case → camelCase mapping
     - Response wrapper pattern (e.g., { "rooms": [...] })
     - Computed properties for display names, dates etc.

  3. API Layer
   
     - Same REST endpoints and HTTP methods                        
     - Same authentication flow (Bearer tokens)                    
     - Same error handling strategy (401 → logout)                 
     - Same multipart upload for images/videos                     

  4. Business Logic                   

     - Chat room management (create, edit, delete, invite)         
     - Ticket/Kanban workflows           
     - Profile editing flows             
     - Blog, Art Gallery, Lyric Lab features                       
     - Session expiration handling       

  5. Real-Time Features               

     - Socket.IO for chat messages and typing indicators           
     - Same event names and payload structures

  6. UI/UX Concepts                   

     - Expandable/collapsible dashboard blocks                     
     - Pull-to-refresh on lists          
     - Swipe-to-delete patterns          
     - Bottom sheets for forms           
     - Confirmation dialogs for destructive actions                
      
  ---       

  What Would Be DIFFERENT             

  1. UI Framework                     

     iOS (SwiftUI)           Android (Jetpack Compose)
     ---------------------   -------------------------      
     @Observable ViewModel   ViewModel + StateFlow       
     @State                  remember { mutableStateOf() }        
     @Environment            CompositionLocalProvider or Hilt             
     NavigationStack         NavHost + NavController                    
     .sheet()                ModalBottomSheet                    
     .task { }               LaunchedEffect                  
     AsyncImage              Coil or Glide                    
     PhotosPicker            ActivityResultContracts.PickVisualMedia                   

  2. State Management                 
       
     // Android equivalent of AuthViewModel                        

     class AuthViewModel : ViewModel() { 
       private val _isAuthenticated = MutableStateFlow(false)    
       val isAuthenticated: StateFlow<Boolean> = _isAuthenticated.asStateFlow()  
          
       private val _currentUser = MutableStateFlow<User?>(null)  
       val currentUser: StateFlow<User?> = _currentUser.asStateFlow()                      
     }         
   
  3. Dependency Injection             

     - iOS uses @Environment for simple injection                  
     - Android would use Hilt/Dagger for proper DI:                

      @HiltViewModel                      

      class ChatViewModel @Inject constructor(                      
          private val chatRepository: ChatRepository,               
          private val socketManager: ChatSocketManager              
      ) : ViewModel()                     
     
  4. Secure Storage                   
 
     iOS                        Android               
     KeychainManager            EncryptedSharedPreferences             
     Keychain Services          AndroidKeyStore           

  5. Networking                       

     iOS                 Android                    
     URLSession          Retrofit + OkHttp                   
     JSONDecoder         Moshi or Gson        
     Async/await         Coroutines + suspend fun │                    

  6. Navigation Patterns              

      // Android Navigation Compose       

      NavHost(navController, startDestination = "breakroom") {      
          composable("breakroom") { BreakroomScreen() }             
          composable("chat") { ChatListScreen() }                   
          composable("chat/{roomId}") { backStackEntry ->           
              ChatRoomScreen(roomId = backStackEntry.arguments?.getString("roomId"))          
          }     
      }         

  7. List Virtualization              

     iOS                   Android  
     LazyVStack / List     LazyColumn    
     LazyHStack            LazyRow    
     ScrollViewReader      LazyListState 

  8. Media Handling                   

     - Video player: ExoPlayer instead of AVKit                    
     - Image loading: Coil/Glide with auth headers                 
     - Camera/gallery: ActivityResultContracts                     
        
  9. Platform-Specific UI             

     iOS   Android               
     SF Symbols                      Material Icons
     .clipShape(RoundedRectangle)    Modifier.clip(RoundedCornerShape)      
     .foregroundStyle(.secondary)    MaterialTheme.colorScheme.onSurfaceVariant         
     System colors                   Material 3 color scheme                   

  10. Widget System (Dashboard Blocks)
     
      The iOS app uses SwiftUI views for widgets. Android equivalent:                         

      @Composable                         
      fun BlockWidgetView(block: BreakroomBlock) {                  
          when (block.type) {             
              BlockType.CHAT -> ChatWidget(block)                   
              BlockType.WEATHER -> WeatherWidget(block)             
              BlockType.CALENDAR -> CalendarWidget(block)           
              // etc.           
          }                      
      }   